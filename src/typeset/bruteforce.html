<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>TypeSet</title>
		<link rel="stylesheet" href="main.css"/>
		<style>		
			canvas {
				border: 1px solid rgb(220, 220, 220);
			}
		</style>
	</head>
	<body>
		<canvas id="canvas" width="350" height="300"></canvas>
		<script type="text/javascript" src="../core/object.js"></script>
		<script type="text/javascript" src="../core/array.js"></script>
		<script type="text/javascript" src="../core/linked-list.js"></script>
		<script type="text/javascript">
			function Node(type, width, options) {
				this.type = type || 'box';
				this.width = width || 0;

				options = options || {};

				this.value = options.value || '';

				this.shrink = options.shrink || 0;
				this.stretch = options.stretch || 0;

				this.penalty = options.penalty || 0;
				this.flagged = options.flagged || 0;
			}

			Node.glue = function (width, stretch, shrink) {
				return new Node('glue', width, {
					'stretch': stretch,
					'shrink': shrink
				});
			};

			Node.box = function (width, value) {
				return new Node('box', width, {
					'value': value
				});
			};

			Node.penalty = function (width, penalty, flagged) {
				return new Node('penalty', width, {
					'penalty': penalty,
					'flagged': flagged
				});
			};

			function BreakPoint(position, demerits, ratio, line, fitnessClass, totals, previous) {
				this.position = position;
				this.demerits = demerits;
				this.ratio = ratio;
				this.line = line;
				this.fitnessClass = fitnessClass;
				this.totals = totals || {
					width: 0,
					stretch: 0,
					shrink: 0
				};
				this.previous = previous;
			}

			BreakPoint.prototype.toString = function () {
				return 'Position: ' + this.position + ', Line: ' + this.line + ', Fitness: ' + this.fitnessClass + ', Ratio: ' + this.ratio + ', Demerits: ' + this.demerits;
			};

			var text = "In olden times when wishing still helped one, there lived a king whose daughters were all beautiful; and the youngest was so beautiful that the sun itself, which has seen so much, was astonished whenever it shone in her face. Close by the king's castle lay a great dark forest, and under an old lime-tree in the forest was a well, and when the day was very warm, the king's child went out to the forest and sat down by the fountain; and when she was bored she took a golden ball, and threw it up on high and caught it; and this ball was her favorite plaything.",

				space = {
					width: 1 / 3,
					stretch: 1 / 6,
					shrink: 1 / 9
				},

				tolerance = 4,

				c = document.getElementById('canvas'),

				context = c.getContext && c.getContext('2d'),

				emWidth,

				words = [],

				lineLengths = [350],	

				nodes = [],

				linePenalty = 10,

				flaggedDemerit = 100,
		
				infinity = 10000,

				fitnessDemerit = 3000,

				align = 'justify';

			context.textBaseline = 'top';
			context.font = '14px times';

			emWidth = context.measureText('M').width;

			maxWidth = context.canvas.width;

			space.width *= emWidth;
			space.stretch *= emWidth;
			space.shrink *= emWidth;

			words = text.split(/\s/);
	
			if (align === 'center') {
				// Although not specified in the Knuth and Plass whitepaper, this box is necessary
				// to keep the glue from disappearing.
				nodes.push(Node.box(0, ''));
				nodes.push(Node.glue(0, 12, 0));
			}

			words.forEach(function (word, index, array) {
				nodes.push(Node.box(context.measureText(word).width, word));

				if (align === 'justify') {
					if (index === array.length - 1) {
						nodes.push(Node.glue(0, infinity, 0));
						nodes.push(Node.penalty(0, -infinity, 1)); 
					} else {
						nodes.push(Node.glue(space.width, space.stretch, space.shrink));
					}
				} else if (align === 'center') {
					if (index === array.length - 1) {
						nodes.push(Node.glue(0, 12, 0));
						nodes.push(Node.penalty(0, -infinity, 0));
					} else {
						nodes.push(Node.glue(0, 12, 0));
						nodes.push(Node.penalty(0, 0, 0));
						nodes.push(Node.glue(space.width, -24, 0));
						nodes.push(Node.box(0, ''));
						nodes.push(Node.penalty(0, infinity, 0));
						nodes.push(Node.glue(0, 12, 0));
					}
				} else if (align === 'left') {
					if (index === array.length - 1) {
						nodes.push(Node.glue(0, infinity, 0));
						nodes.push(Node.penalty(0, -infinity, 1)); 
					} else {
						nodes.push(Node.glue(0, 12, 0));
						nodes.push(Node.penalty(0, 0, 0));
						nodes.push(Node.glue(space.width, -12, 0)); 
					}
				}
			});

			function computeCost(start, end, active, currentLine) {
				var width = sum.width - active.totals.width,
					stretch = 0,
					shrink = 0,
					// If the current line index is within the list of linelengths, use it, otherwise use
					// the last line length of the list.
					lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];

				if (nodes[end].type === 'penalty') {
					width += nodes[end].width;
				}

				if (width < lineLength) {
					// Calculate the stretch ratio
					stretch = sum.stretch - active.totals.stretch;

					if (stretch > 0) {
						return (lineLength - width) / stretch;
					} else {
						return infinity;
					}

				} else if (width > lineLength) {
					// Calculate the shrink ratio
					shrink = sum.shrink - active.totals.shrink;

					if (shrink > 0) {
						return (lineLength - width) / shrink;
					} else {
						return infinity;
					}
				} else {
					// perfect match
					return 0;
				}
			}

			// Add width, stretch and shrink values from the current 
			// break point up to the next box or forced penalty.
			function computeSum(breakPointIndex) {
				var result = {
						width: sum.width,
						stretch: sum.stretch,
						shrink: sum.shrink
					},
					i = 0;

				for (i = breakPointIndex; i < nodes.length; i += 1) {
					if (nodes[i].type === 'glue') {
						result.width += nodes[i].width;
						result.stretch += nodes[i].stretch;
						result.shrink += nodes[i].shrink;
					} else if (nodes[i].type === 'box' || (nodes[i].type === 'penalty' && nodes[i].penalty === -infinity && i > breakPointIndex)) {
						break;
					}
				}
				return result;
			}

			function inOrder(activeNodes) {
				var line = -1,
					position = -1,
					fitnessClass = -1;
					active = activeNodes.first(),
					inorder = true;
				while (active !== null) {
					// if the lines are different, position does not matter
					if (line < active.data.line) {
					// if the lines are the same, the position should be different
					} else if (line === active.data.line && position !== active.data.position) {
					// if the lines and position are the same the fitness classes should be different.
					} else if (line === active.data.line && position === active.data.position && fitnessClass !== active.data.fitnessClass) {
					} else {
						break;
					}
					position = active.data.position;
					line = active.data.line;
					fitnessClass = active.data.fitnessClass;
					active = active.next;
				}
				return inorder;
			}

			var activeNodes = new LinkedList(),
				sum = {
					width: 0,
					stretch: 0,
					shrink: 0
				};

			activeNodes.push(new LinkedList.Node(new BreakPoint(0, 0, 0, 0, 0, undefined, null)));

			function mainLoop(node, index, nodes) {
				var active = activeNodes.first(),
					next = null,
					ratio = 0,
					demerits = 0,
					candidates = [],
					badness,
					currentLine = 0,
					tmpSum,
					currentClass = 0;

				// The inner loop iterates through all the active nodes with line < currentLine and then
				// breaks out to insert the new active node candidates before looking at the next active
				// nodes for the next lines. The result of this is that the active node list is always
				// sorted by line number.
				while (active !== null) {

					candidates = [{demerits: Infinity}, {demerits: Infinity}, {demerits: Infinity}, {demerits: Infinity}];

					// Iterate through the linked list of active nodes to find new potential active nodes 
					// and deactivate current active nodes.
					while (active !== null) {
						next = active.next;
						currentLine = active.data.line + 1;
						ratio = computeCost(active.data.position, index, active.data, currentLine);

						// Deactive nodes when the the distance between the current active node and the
						// current node becomes too large (i.e. it exceeds the stretch limit and the stretch
						// ratio becomes negative) or when the current node is a forced break (i.e. the end
						// of the paragraph when we want to remove all active nodes, but possibly have a final
						// candidate active node---if the paragraph can be set using the given tolerance value.)
						if (ratio < -1 || (node.type === 'penalty' && node.penalty === -infinity)) {
							activeNodes.remove(active);
						}

						// If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the 
						// total demerits and record a candidate active node.
						if (-1 <= ratio && ratio <= tolerance) {
							badness = 100 * Math.pow(Math.abs(ratio), 3);

							// Positive penalty
							if (node.type === 'penalty' && node.penalty >= 0) {
								demerits = Math.pow(linePenalty + badness + node.penalty, 2);
							// Negative penalty but not a forced break
							} else if (node.type === 'penalty' && node.penalty !== -infinity) {
								demerits = Math.pow(linePenalty + badness - node.penalty, 2);
							// All other cases
							} else {
								demerits = Math.pow(linePenalty + badness, 2);
							}

							if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {
								demerits += flaggedDemerit * node.flagged * nodes[active.data.position].flagged;
							}

							// Calculate the fitness class for this candidate active node.
							if (ratio < -0.5) {
								currentClass = 0;
							} else if (ratio <= 0.5) {
								currentClass = 1;
							} else if (ratio <= 1) {
								currentClass = 2;
							} else {
								currentClass = 3;
							}

							// Add a fitness penalty to the demerits if the fitness classes of two adjacent lines
							// differ too much.
							if (Math.abs(currentClass - active.data.fitnessClass) > 1) {
								demerits += fitnessDemerit;
							}

							// Add the total demerits of the active node to get the total demerits of this candidate node.
							demerits += active.data.demerits;

							// Only store the best candidate for each fitness class
							if (demerits < candidates[currentClass].demerits) {
								candidates[currentClass] = {active: active, demerits: demerits, ratio: ratio};
							}
						}

						active = next;

						// Stop iterating through active nodes to insert new candidate active nodes in the active list
						// before moving on to the active nodes for the next line.
						// TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs
						// with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.
						// For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node
						// list sorted has a higher priority.
						if (active !== null && active.data.line >= currentLine) {
							break;
						}
					}

					tmpSum = computeSum(index);

					candidates.forEach(function (candidate, fitnessClass) {
						var newNode;

						if (candidate.demerits < Infinity) {
							newNode = new LinkedList.Node(new BreakPoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));
							if (active !== null) {
								activeNodes.insertBefore(active, newNode);
							} else {
								activeNodes.push(newNode);
							}
							if (!inOrder(activeNodes)) { console.log(activeNodes.toString()); }
						}
					});
				}
			}

			nodes.forEach(function (node, index, nodes) {
				if (node.type === 'box') {
					sum.width += node.width;
				} else if (node.type === 'glue') {
					if (index > 0 && nodes[index - 1].type === 'box') {
						mainLoop(node, index, nodes);
					}
					sum.width += node.width;
					sum.stretch += node.stretch;
					sum.shrink += node.shrink;
				} else if (node.type === 'penalty' && node.penalty !== infinity) {
					mainLoop(node, index, nodes);
				}
			});

			/**
			 * Output code
			 */
			if (activeNodes.size() !== 0) {
				var i = 0, lines = [], point, j, r, lineStart = 0, y = 4, tmp, breaks = [];

				tmp = activeNodes.first();

				while (tmp !== null) {
					breaks.push({position: tmp.data.position, ratio: tmp.data.ratio});
					tmp = tmp.data.previous;
				}
				breaks = breaks.reverse();

				for (i = 1; i < breaks.length; i += 1) {
					point = breaks[i].position,
					r = breaks[i].ratio;

					for (var j = lineStart; j < nodes.length; j += 1) {
						if (nodes[j].type === 'box' || (nodes[j].type === 'penalty' && nodes[j].penalty === -infinity)) {
							lineStart = j;
							break;
						}
					}
					lines.push({ratio: r, nodes: nodes.slice(lineStart, point + 1), position: point});
					lineStart = point;
				}

				lines.forEach(function (line, lineIndex) {
					var x = 0;

					line.nodes.forEach(function (node, index) {
						if (node.type === 'box') {
							context.fillText(node.value, x, y);
							x += node.width;
						} else if (node.type === 'glue') {
							x += node.width + line.ratio * (line.ratio < 0 ? node.shrink : node.stretch);
						}
					});
					y += 21;
				});
			} else {
				console.log("Paragraph can not be set with given tolerance.");
			}
		</script>
	</body>
</html>

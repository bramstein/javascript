<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>TypeSet</title>
		<link rel="stylesheet" href="main.css"/>
		<style>		
			canvas {
				border: 1px solid red;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas" width="350" height="300"></canvas>
		<script type="text/javascript" src="../core/object.js"></script>
		<script type="text/javascript" src="../core/array.js"></script>
		<script type="text/javascript" src="../core/linked-list.js"></script>
		<script type="text/javascript">
			var text = "In olden times when wishing still helped one, there lived a king whose daughters were all beautiful; and the youngest was so beautiful that the sun itself, which has seen so much, was astonished whenever it shone in her face. Close by the king's castle lay a great dark forest, and under an old lime-tree in the forest was a well, and when the day was very warm, the king's child went out to the forest and sat down by the fountain; and when she was bored she took a golden ball, and threw it up on high and caught it; and this ball was her favorite plaything.",

				space = {
					width: 1 / 3,
					stretch: 1 / 6,
					shrink: 1 / 9
				},

				tolerance = 1.2,

				c = document.getElementById('canvas'),

				context = c.getContext && c.getContext('2d'),

				emWidth,

				words = [],

				maxWidth,

				breaks = [],
		
				tmp;

			context.textBaseline = 'top';
			context.font = '14px times';

			emWidth = context.measureText('M').width;

			maxWidth = context.canvas.width;

			space.width *= emWidth;
			space.stretch *= emWidth;
			space.shrink *= emWidth;

			console.log(maxWidth);

			words = text.split(/\s/);

			function computeCost(start, end) {
				var i, width = 0, stretch = 0, shrink = 0, spaces = 0;
			
				for (i = start; i < end; i += 1) {
					width += context.measureText(words[i]).width;
				}
				// add the normal space width
				if (end - start > 1) {
					spaces = (end - start) - 1;
				}

				width += spaces * space.width;

				if (width < maxWidth) {
					// Calculate the stretch ratio
					
					stretch = spaces * space.stretch;
					if (stretch > 0) {
						return (maxWidth - width) / stretch;
					} else {
						return 10000;
					}

				} else if (width > maxWidth) {
					// Calculate the shrink ratio
					shrink = spaces * space.shrink;
					if (shrink > 0) {
						return (maxWidth - width) / shrink;
					} else {
						return 10000;
					}
				} else {
					// perfect match
					return 0;
				}
			}

			function BreakPoint(position, demerits, ratio, line, previous) {
				this.position = position;
				this.demerits = demerits;
				this.ratio = ratio;
				this.line = line;
				this.previous = previous;
			}

			BreakPoint.prototype.toString = function () {
				return 'Position: ' + this.position + ', Ratio: ' + this.ratio;
			};

			var candidates = new LinkedList(),
				currentLine = 0, i = 0, lines = [], point, j, r, lineStart = 0, y = 4;

			candidates.push(new LinkedList.Node(new BreakPoint(0, 0, 0, 0, null)));


			words.forEach(function (word, index) {
				var active = candidates.first(),
					next = null,
					ratio = 0,
					demerits = 0,
					potentials = [],
					badness;

				while (active !== null) {
					next = active.next;
					ratio = computeCost(active.data.position, index);

					currentLine = active.data.line + 1;

					if (ratio < -1 || index === words.length - 1) {
						candidates.remove(active);
					}

					if (-1 <= ratio && ratio <= tolerance) {
						badness = 100 * Math.pow(Math.abs(ratio), 3);
						demerits = Math.pow(1 + badness, 2);

						potentials.push(new LinkedList.Node(new BreakPoint(index, active.data.demerits + demerits, ratio, active.data.line + 1, active)));
					}
					active = next;
				}
				if (!potentials.isEmpty()) {
					var b = potentials.reduce(function (a, b) {
						return a.data.demerits < b.data.demerits ? a : b;
					}, {data: {ratio: Infinity}});
					candidates.push(b);
				}
			});


			if (candidates.size() !== 0) {
				tmp = candidates.first();

				while (tmp !== null) {
					breaks.push({position: tmp.data.position, ratio: tmp.data.ratio});
					tmp = tmp.data.previous;
				}
				breaks = breaks.reverse();

				for (i = 1; i < breaks.length; i += 1) {

					point = breaks[i].position,
					r = breaks[i].ratio;
				//	console.log(words.slice(lineStart, point));
				//	console.log(r + ' ' + computeCost(lineStart, point) + ' ' + lineStart + ' ' + point);
					lines.push({ratio: r, nodes: words.slice(lineStart, point), position: point});
					lineStart = point;
				}

				console.log(lines);

				lines.forEach(function (line, lineIndex) {
					var w = space.width + line.ratio * (line.ratio < 0 ? space.shrink : space.stretch),
						x = 0;

					console.log(line.ratio);

					line.nodes.forEach(function (word, index) {
						context.fillText(word, x, y);
						x += context.measureText(word).width;
						if (index !== line.nodes.length - 1 && lineIndex !== lines.length -1) {
							x += w;
						} else if (lineIndex === lines.length - 1) {
							x += space.width;
						}
					});
					y += 21;
				});
			} else {
				console.log("Paragraph can not be set with given tolerance.");
			}
		
/*
			// So now we have a tree of potential break points, and we need to find the route with
			// the least total costs. We start searching for possible routes at the end of the candidate
			// list. If the candidate list does not contain the end of the list, this paragraph can not
			// be set using the given tolerance parameter.
			potentials = potentials.reverse();

			var routes = potentials.filter(function (p) {
				return p.end === words.length - 1;
			});

			totalCost = 0;

			routes.forEach(function (n) {
				function find(node) {
					node.cost += Math.abs(node.ratio);
					
					if (node.start === 0) {
						console.log(totalCost);
						return;
					} else {
						// find the node(s) this one is pointing to
						var startNodes = potentials.filter(function (p) {
							return p.end === node.start;
						});
						console.log(startNodes);
						startNodes.forEach(find);
					}
				}

				find(n);
			});
			console.log(routes);
*/
			/*potentials.forEach(function (p) {
				var nextPotentials = potentials.filter(function (np) {
					return np.start === p.end;
				});
				console.log(nextPotentials);
			});*/
		</script>
	</body>
</html>

<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>TypeSet</title>
		<link rel="stylesheet" href="main.css"/>
		<style>		
			canvas {
				/*border: 1px solid rgb(220, 220, 220);*/
			}
		</style>
	</head>
	<body>
		<canvas id="canvas" width="350" height="300"></canvas>
		<script type="text/javascript" src="../core/object.js"></script>
		<script type="text/javascript" src="../core/array.js"></script>
		<script type="text/javascript" src="../core/linked-list.js"></script>
		<script type="text/javascript">
			function Node(type, width, options) {
				this.type = type || 'box';
				this.width = width || 0;

				options = options || {};

				this.value = options.value || '';

				this.shrink = options.shrink || 0;
				this.stretch = options.stretch || 0;

				this.penalty = options.penalty || 0;
				this.flagged = options.flagged || 0;
			}

			Node.glue = function (width, stretch, shrink) {
				return new Node('glue', width, {
					'stretch': stretch,
					'shrink': shrink
				});
			};

			Node.box = function (width, value) {
				return new Node('box', width, {
					'value': value
				});
			};

			Node.penalty = function (width, penalty, flagged) {
				return new Node('penalty', width, {
					'penalty': penalty,
					'flagged': flagged
				});
			};

			var text = "In olden times when wishing still helped one, there lived a king whose daughters were all beautiful; and the youngest was so beautiful that the sun itself, which has seen so much, was astonished whenever it shone in her face. Close by the king's castle lay a great dark forest, and under an old lime-tree in the forest was a well, and when the day was very warm, the king's child went out to the forest and sat down by the fountain; and when she was bored she took a golden ball, and threw it up on high and caught it; and this ball was her favorite plaything.",

				space = {
					width: 1 / 3,
					stretch: 1 / 6,
					shrink: 1 / 9
				},

				tolerance = 4,

				c = document.getElementById('canvas'),

				context = c.getContext && c.getContext('2d'),

				emWidth,

				words = [],

				maxWidth,

				breaks = [],
		
				tmp,
	
				nodes = [],
		
				infinity = 10000,

				align = 'left';

			context.textBaseline = 'top';
			context.font = '14px times';

			emWidth = context.measureText('M').width;

			maxWidth = context.canvas.width;

			space.width *= emWidth;
			space.stretch *= emWidth;
			space.shrink *= emWidth;

			words = text.split(/\s/);
	
			if (align === 'center') {
				nodes.push(Node.box(0, ''));
				nodes.push(Node.glue(0, 12, 0));
			}

			words.forEach(function (word, index, array) {
				nodes.push(Node.box(context.measureText(word).width, word));

				if (align === 'justify') {
					if (index === array.length - 1) {
						nodes.push(Node.glue(0, infinity, 0));
						nodes.push(Node.penalty(0, -infinity, 1)); 
					} else {
						nodes.push(Node.glue(space.width, space.stretch, space.shrink));
					}
				} else if (align === 'center') {
					if (index === array.length - 1) {
						nodes.push(Node.glue(0, 12, 0));
						nodes.push(Node.penalty(0, -infinity, 0));
					} else {
						nodes.push(Node.glue(0, 12, 0));
						nodes.push(Node.penalty(0, 0, 0));
						nodes.push(Node.glue(space.width, -24, 0));
						nodes.push(Node.box(0, ''));
						nodes.push(Node.penalty(0, infinity, 0));
						nodes.push(Node.glue(0, 12, 0));
					}
				} else if (align === 'left') {
					if (index === array.length - 1) {
						nodes.push(Node.glue(0, infinity, 0));
						nodes.push(Node.penalty(0, -infinity, 1)); 
					} else {
						nodes.push(Node.glue(0, 12, 0));
						nodes.push(Node.penalty(0, 0, 0));
						nodes.push(Node.glue(space.width, -12, 0)); 
					}
				}
			});

			function computeCost(start, end) {
				var i, width = 0, stretch = 0, shrink = 0;

				// find the first box or non-forced penalty after the previous breakpoint.
				for (i = start; i < nodes.length; i += 1) {
					if (nodes[i].type === 'box' || (nodes[i].type === 'penalty' && nodes[i].penalty === -infinity)) {
						start = i;
						break;
					}
				}

				for (i = start; i < end; i += 1) {
					if (nodes[i].type === 'box') {
						width += context.measureText(nodes[i].value).width;
					} else if (nodes[i].type === 'glue') {
						width += nodes[i].width;
						stretch += nodes[i].stretch;
						shrink += nodes[i].shrink;
					}
				}

				if (nodes[end].type === 'penalty') {
					width += nodes[end].width;
				}

				if (width < maxWidth) {
					// Calculate the stretch ratio
					if (stretch > 0) {
						return (maxWidth - width) / stretch;
					} else {
						return infinity;
					}

				} else if (width > maxWidth) {
					// Calculate the shrink ratio
					if (shrink > 0) {
						return (maxWidth - width) / shrink;
					} else {
						return infinity;
					}
				} else {
					// perfect match
					return 0;
				}
			}

			function BreakPoint(position, demerits, ratio, line, previous) {
				this.position = position;
				this.demerits = demerits;
				this.ratio = ratio;
				this.line = line;
				this.previous = previous;
			}

			BreakPoint.prototype.toString = function () {
				return 'Position: ' + this.position + ', Ratio: ' + this.ratio + ', Demerits: ' + this.demerits;
			};

			var candidates = new LinkedList(),
				currentLine = 0, i = 0, lines = [], point, j, r, lineStart = 0, y = 4;

			candidates.push(new LinkedList.Node(new BreakPoint(0, 0, 0, 0, null)));

			nodes.forEach(function (node, index) {
				var active = candidates.first(),
					next = null,
					ratio = 0,
					demerits = 0,
					potentials = [],
					badness;

				if ((index > 0 && node.type === 'glue' && nodes[index - 1].type === 'box') || (node.type === 'penalty' && node.penalty !== infinity)) {
					while (active !== null) {
						next = active.next;
						ratio = computeCost(active.data.position, index);

						currentLine = active.data.line + 1;

						if (ratio < -1 || (node.type === 'penalty' && node.penalty === -infinity)) {
							candidates.remove(active);
						}

						if (-1 <= ratio && ratio <= tolerance) {
							badness = 100 * Math.pow(Math.abs(ratio), 3);
							demerits = Math.pow(1 + badness, 2);

							potentials.push({active: active, demerits: active.data.demerits + demerits, ratio: ratio});
						}
						active = next;
					}
					if (!potentials.isEmpty()) {
						var b = potentials.reduce(function (a, b) {
							return a.demerits < b.demerits ? a : b;
						}, {demerits: Infinity});
						
						candidates.push(new LinkedList.Node(new BreakPoint(index, b.demerits, b.ratio, b.active.data.line + 1, b.active)));
					}
				}
			});
			if (candidates.size() !== 0) {
				tmp = candidates.first();

				while (tmp !== null) {
					breaks.push({position: tmp.data.position, ratio: tmp.data.ratio});
					tmp = tmp.data.previous;
				}
				breaks = breaks.reverse();

				for (i = 1; i < breaks.length; i += 1) {
					point = breaks[i].position,
					r = breaks[i].ratio;

					for (var j = lineStart; j < nodes.length; j += 1) {
						if (nodes[j].type === 'box' || (nodes[j].type === 'penalty' && nodes[j].penalty === -infinity)) {
							lineStart = j;
							break;
						}
					}

					lines.push({ratio: r, nodes: nodes.slice(lineStart, point + 1), position: point});
					lineStart = point;
				}

				lines.forEach(function (line, lineIndex) {
					var x = 0;

					line.nodes.forEach(function (node, index) {
						if (lineIndex === 1) {
							console.log(node);
						}
						if (node.type === 'box') {
							context.fillText(node.value, x, y);
							x += node.width;
						} else if (node.type === 'glue') {
							x += node.width + line.ratio * (line.ratio < 0 ? node.shrink : node.stretch);
						}
					});
					y += 21;
				});
			} else {
				console.log("Paragraph can not be set with given tolerance.");
			}
		</script>
	</body>
</html>

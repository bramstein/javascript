<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>TypeSet</title>
		<link rel="stylesheet" href="main.css"/>
		<style>		
			canvas {
				/*border: 1px solid rgb(220, 220, 220);*/
			}
		</style>
	</head>
	<body>
		<canvas id="canvas" width="350" height="300"></canvas>
		<script type="text/javascript" src="../core/object.js"></script>
		<script type="text/javascript" src="../core/array.js"></script>
		<script type="text/javascript" src="../core/linked-list.js"></script>
		<script type="text/javascript">
			var text = "In olden times when wishing still helped one, there lived a king whose daughters were all beautiful; and the youngest was so beautiful that the sun itself, which has seen so much, was astonished whenever it shone in her face. Close by the king's castle lay a great dark forest, and under an old lime-tree in the forest was a well, and when the day was very warm, the king's child went out to the forest and sat down by the fountain; and when she was bored she took a golden ball, and threw it up on high and caught it; and this ball was her favorite plaything.",

				space = {
					width: 1 / 3,
					stretch: 1 / 6,
					shrink: 1 / 9
				},

				tolerance = 1,

				c = document.getElementById('canvas'),

				context = c.getContext && c.getContext('2d'),

				emWidth,

				words = [],

				maxWidth,

				breaks = [],
		
				tmp;

			context.textBaseline = 'top';
			context.font = '14px times';

			emWidth = context.measureText('M').width;

			maxWidth = context.canvas.width;

			space.width *= emWidth;
			space.stretch *= emWidth;
			space.shrink *= emWidth;

			words = text.split(/\s/);

			function computeCost(start, end) {
				var i, width = 0, stretch = 0, shrink = 0, spaces = 0;
			
				for (i = start; i < end; i += 1) {
					width += context.measureText(words[i]).width;
				}
				// add the normal space width
				if (end - start > 1) {
					spaces = (end - start) - 1;
				}

				

				width += spaces * space.width;
				//console.log(width);
				if (width < maxWidth) {
					// Calculate the stretch ratio
					
					stretch = spaces * space.stretch;

					if (end === words.length - 1) {
						stretch = 10000;
					}
					if (stretch > 0) {
						return (maxWidth - width) / stretch;
					} else {
						return 10000;
					}

				} else if (width > maxWidth) {
					// Calculate the shrink ratio
					shrink = spaces * space.shrink;
					if (shrink > 0) {
						return (maxWidth - width) / shrink;
					} else {
						return 10000;
					}
				} else {
					// perfect match
					return 0;
				}
			}

			function BreakPoint(position, demerits, ratio, line, previous) {
				this.position = position;
				this.demerits = demerits;
				this.ratio = ratio;
				this.line = line;
				this.previous = previous;
			}

			BreakPoint.prototype.toString = function () {
				return 'Position: ' + this.position + ', Ratio: ' + this.ratio + ', Demerits: ' + this.demerits;
			};

			var candidates = new LinkedList(),
				currentLine = 0, i = 0, lines = [], point, j, r, lineStart = 0, y = 4;

			candidates.push(new LinkedList.Node(new BreakPoint(0, 0, 0, 0, null)));


			words.forEach(function (word, index) {
				var active = candidates.first(),
					next = null,
					ratio = 0,
					demerits = 0,
					potentials = [],
					badness;

				while (active !== null) {
					next = active.next;
					ratio = computeCost(active.data.position, index);

					currentLine = active.data.line + 1;

					if (ratio < -1 || index === words.length - 1) {
						candidates.remove(active);
					}

					if (-1 <= ratio && ratio <= tolerance) {
						badness = 100 * Math.pow(Math.abs(ratio), 3);
						demerits = Math.pow(1 + badness, 2);

						potentials.push({active: active, demerits: active.data.demerits + demerits, ratio: ratio});
					}
					active = next;
				}
				if (!potentials.isEmpty()) {
					var b = potentials.reduce(function (a, b) {
						return a.demerits < b.demerits ? a : b;
					}, {demerits: Infinity});
					if (b.demerits < 10000) {
						candidates.push(new LinkedList.Node(new BreakPoint(index, b.demerits, b.ratio, b.active.data.line + 1, b.active)));
					}
				}
			});

			if (candidates.size() !== 0) {
				tmp = candidates.first();

				while (tmp !== null) {
					breaks.push({position: tmp.data.position, ratio: tmp.data.ratio});
					tmp = tmp.data.previous;
				}
				breaks = breaks.reverse();

				for (i = 1; i < breaks.length; i += 1) {

					point = breaks[i].position,
					r = breaks[i].ratio;
					lines.push({ratio: r, nodes: words.slice(lineStart, point + 1), position: point});
					lineStart = point;
				}

				lines.forEach(function (line, lineIndex) {
					var w = space.width + line.ratio * (line.ratio < 0 ? space.shrink : space.stretch),
						x = 0;

					console.log(line.ratio);

					line.nodes.forEach(function (word, index) {
						context.fillText(word, x, y);
						x += context.measureText(word).width;
						if (index !== line.nodes.length - 1 && lineIndex !== lines.length -1) {
							x += w;
						} else if (index !== line.nodes.length - 1 && lineIndex === lines.length - 1) {
							x += space.width;
						}
					});
					y += 21;
				});
			} else {
				console.log("Paragraph can not be set with given tolerance.");
			}
		</script>
	</body>
</html>

<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>TypeSet</title>
		<link rel="stylesheet" href="main.css"/>
		<style>
			.example {
				overflow: auto;
				margin-left: 25%;
			}

			.example ul {
				width: 4em;
				float: left;
				list-style-type: none;
				margin: 0;
				padding: 0;
			}

			.example ul li {
				margin: 0;
				padding: 0;
				text-align: right;
			}

			.example p {
				margin: 0;
				padding: 0;
			}

			#browser, #browser-assisted, .example {
				font-size: 14px;
				line-height: 21px;
				font-family: 'times';
				text-align: justify;
			}

			#browser, #browser-assisted {
				width: 350px;
				float: left;
			}

			#browser-assisted {
				text-align: left;
			}

			#canvas {
				width: 350px;
				height: 200px;
				float: left;
			}
		</style>
	</head>
	<body>
		<h1><span class="tex">T<sub>e</sub>X</span> line breaking algorithm in HTML5 Canvas</h1>
		<p class="subtitle">Bram Stein (<a href="http://www.bramstein.com/">http://www.bramstein.com</a> - <a href="mailto:b.l.stein@gmail.com">b.l.stein@gmail.com</a>)</p>

		<p>This is an implementation of the <a href="http://www3.interscience.wiley.com/journal/113445055/abstract">Knuth and Plass line breaking algorithm</a> using JavaScript and the HTML5 canvas element. The goal of this implementation is to optimally set text in the new HTML5 canvas element, and ultimately implement a rich text editor using JavaScript and HTML5 features.</p>
		<p>The paragraph below is set using a (simplified) JavaScript implementation of the classic Knuth and Plass algorithm as used in <span class="tex">T<sub>e</sub>X</span>. The numbers on the right of each line are the stretching or shrinking ratio compared to the optimal line width. This example uses a default space of <sup>1</sup>⁄<sub>3</sub> em width, with a stretchability and shrink-ability of <sup>1</sup>⁄<sub>6</sub> em and <sup>1</sup>⁄<sub>9</sub> em respectively.</p>
		<div class="example"><canvas id="canvas" width="350" height="200"></canvas></div>
		<p>The following paragraph is set by your browser using <code>text-align: justify</code>. Notice the second and fifth line have greater inter-word spacing than the canvas version, which stretches the first line in order to minimize the inter-word spacing in later lines.</p>
		<div class="example"><p id="browser"></p></div>
		<p> The browser also ends up with ten lines instead of the nine found by the Knuth and Plass line breaking algorithm. This comparison might not be completely fair since we don't know the default inter-word space used by the browser (nor its stretching and shrinking parameters.) Experimental results however indicate the values used in Firefox are either identical or very similar. The next section explains how the values for your browser were calculated.</p>

		<h2>Measuring the quality of browser line breaks</h2>
		<p>Unfortunately there is no API to retrieve the positions of the line breaks the browser inserted so we'll have to resort to some trickery. By wrapping each word in an invisible <code>&lt;span&gt;</code> element and retrieving its <code>y</code> position we can find out when a new line starts. If the <code>y</code> position of the current word is different from the previous word we know a new line has started. This way a paragraph is split up in several individual lines.</p>

		<p>The ratios are then calculated by measuring the difference between the width of each line when <code>text-align</code> is set to <code>justify</code> and when it is set to <code>right</code>. This difference is then divided by the amount of stretchability of the line: i.e. the number of spaces multiplied by the stretch parameter for spaces. Although we don't know the actual stretchability we can use <sup>1</sup>⁄<sub>6</sub> em, just like the Knuth and Plass algorithm, if we only use it for comparison.</p>

		<h2>Assisted browser line breaks</h2>
		<p>The following paragraph is set according to the line breaks found by the Knuth and Plass algorithm, but instead of using the HTML5 Canvas element it is rendered by your browser. By adjusting the CSS <code>word-spacing</code> property we have achieved the same paragraph as in the Canvas example.</p>
		<div class="example"><p id="browser-assisted"></p></div>
		<p>Each line is wrapped in a <code>&lt;span&gt;</code> element, with the same stretchability and shrink-ability values as in the Canvas example. These values are multiplied by the stretch or shrink ratio and used as the word spacing for that line.</p>
		<h2>Examples</h2>
		<h3>Ragged right, ragged left and centered alignment</h3>
		<h3>Variable line width</h3>
		<p>Variable line width to flow text around illustrations, asides, quotes and the like.</p>

		<h2>To-do</h2>
		<p>The following are some extensions to the algorithm discussed in the original paper, which I intend to implement (at some point.)</p>
		<ul>
			<li>Fitness classes to classify lines into different ratio categories (e.g. tight, loose, very loose) etc. This can then be used to avoid adjacent lines with fitness classes that lie too far apart.</li>
			<li>Hyphenation using <a href="http://www.tug.org/docs/liang/">Frank Liang's algorithm</a>. This will also improve the quality of the line breaks as it introduces more potential line breaks in a paragraph.</li>
			<li><a href="http://en.wikipedia.org/wiki/Hanging_punctuation">Hanging punctuation</a>. A quote from the original Knuth and Plass paper explains how to implement it: 

				<blockquote>Some people prefer to have the right edge of their text look ‘solid’, by setting periods,
				commas, and other punctuation marks (including inserted hyphens) in the right-hand
				margin. For example, this practice is occasionally used in contemporary advertising.
				It is easy to get inserted hyphens into the margin: We simply let the width of the
				corresponding penalty item be zero. And it is almost as easy to do the same for periods
				and other symbols, by putting every such character in a box of width zero and adding
				the actual symbol width to the glue that follows. If no break occurs at this glue, the
				accumulated width is the same as before; and if a break does occur, the line will be
				justified as if the period or other symbol were not present.</blockquote>
			</li>
			<li>The current code uses the global name-space for variables and functions, it would be good to wrap these up in a module, with a well defined API.</li>
			<li>Test in other browsers: currently it seems to work fine with Firefox on Linux and Windows. Firefox on OSX, however performs badly (seems to be caused by strange font metrics, and bad anti-aliasing.) Also works fine with Safari on OSX.</li>
			<li>Compare quality against line-breaking implemented by Internet Explorer's <code>text-justify</code> CSS property.</li>
		</ul>

		<h2>To don't</h2>
		<ul>
			<li>The original Knuth and Plass algorithm includes a "looseness" parameter to set a paragraph using more lines than the optimal solution. As far as I can tell this is used to "squeeze" a paragraph on a page near a section end. I currently have no need for that as web pages are virtually unlimited in vertical space.</li>
		</ul>

		<h2>Source code</h2>
		<ul>
			<li><a href="myfit.js">myfit.js</a> (main algorithm, drawing routines are in this document.)</li>
		</ul>
		<h2>References</h2>
		<p>These are the resources I found most useful while implementing the line breaking algorithm.</p>
		<ul>
			<li><a href="http://www.amazon.com/Digital-Typography-Center-Language-Information/dp/1575860104/">Digital Typography, Donald E. Knuth</a></li>
			<li><a href="http://www3.interscience.wiley.com/journal/113445055/abstract">Breaking paragraphs into lines, Donald E. Knuth, Michael F. Plass</a></li>
			<li><a href="http://defoe.sourceforge.net/folio/knuth-plass.html">Knuth & Plass line-breaking Revisited</a></li>
			<li><a href="http://en.wikipedia.org/w/index.php?title=Word_wrap&oldid=336270336">Wikipedia: Word wrap</a></li>
		</ul>
		<script type="text/javascript" src="../core/object.js"></script>
		<script type="text/javascript" src="../core/array.js"></script>
		<script type="text/javascript" src="../core/array.extra.js"></script>
		<script type="text/javascript" src="../../lib/jquery-1.3.2.js"></script>
		<script type="text/javascript" src="myfit.js"></script>
		<script type="text/javascript">
			var text = "In olden times when wishing still helped one, there lived a king whose daughters were all beautiful; and the youngest was so beautiful that the sun itself, which has seen so much, was astonished whenever it shone in her face. Close by the king's castle lay a great dark forest, and under an old lime-tree in the forest was a well, and when the day was very warm, the king's child went out to the forest and sat down by the fountain; and when she was bored she took a golden ball, and threw it up on high and caught it; and this ball was her favorite plaything.";
			var defaultOptions = {
				space: {
					width: 1 / 3,
					stretch: 1 / 6,
					shrink: 1 / 9
				},
				tolerance: 1
			};


			var typeset = function(measureText, options) {
				
			};

			function setJustified(text, lineLengths, measureText, options) {
				var em = measureText("M").width,
					spaceWidth = options.space.width * em,
					spaceStretch = options.space.stretch * em,
					spaceShrink = options.space.shrink * em,
					words = text.split(/\s/),
					list = [],
					type = 'left';

				words.forEach(function (value, index, array) {
					list.push(new Box(measureText(value).width, value));

					if (index === array.length - 1) {
						list.push(new Glue(0, infinity, 0));
						list.push(new Penalty(0, -infinity, 1));
					} else {
						if (type === 'justify') {
							list.push(new Glue(spaceWidth, spaceStretch, spaceShrink));
						} else if (type === 'left') {
							list.push(new Glue(0, 12, 0));
							list.push(new Penalty(0, 0, 0));
							list.push(new Glue(spaceWidth, -12, 0));
						}
					}
				});

				init(list);

				var breakPoints = computeBreakPoints(list, lineLengths, options),
					lineStart = 0, r = 0, point, j = 0, i = 1, node, lines = [];

				for (i = 1; i < breakPoints.length; i += 1) {
					point = breakPoints[i].position,
					r = breakPoints[i].ratio;

					lines.push({ratio: r, nodes: [], position: point});
					for (j = lineStart; j < point; j += 1) {
						node = list[j];

						if (node.type === 'glue') {
							node.width = node.computeWidth(r);
							lines.peek().nodes.push(node);
						} else if (node.type === 'box') {
							lines.peek().nodes.push(node);
						}
					}
					lineStart = point + 1;
				}
				return lines;
			}

			function drawLines(context, lines, lineHeight) {
				// this is here so that it aligns better with
				// the browser drawn ratio list.
				var y = 4;

				lines.forEach(function (line) {
					var x = 0;
					line.nodes.forEach(function (node) {
						if (node.type === 'box') {
							context.fillText(node.value, x, y);
							x += node.width;
						} else if (node.type === 'glue') {
							x += node.width;	
						}
					});
					y += lineHeight;
				});
			}

			function canvasTypeset() {
				var c = document.getElementById('canvas'),
					context = null,
					lines = [],
					html = [];

				if (c.getContext && c.getContext('2d')) {
					context = c.getContext('2d');
					context.textBaseline = 'top';
					context.font = '14px times';

					lines = setJustified(text, [350], function (str) { return context.measureText(str); }, defaultOptions);
					drawLines(context, lines, 21);

					html.push('<ul>');
					lines.forEach(function (line) {
						html.push('<li>');
						html.push(line.ratio.toFixed(3));
						html.push('</li>');
					});
					html.push('</ul>');
	
					$('#canvas').parent().append(html.join(''));

					
					lines.forEach(function (l) {
						var spaceShrink = 1 / 9 * 12,
							spaceStretch = 1 / 6 * 12;
						var t = $('<span>' + l.nodes.filter(function (n) { 
							return n.type === 'box';
						}).map(function (n) {
							return n.value;
						}).join(' ') + '</span>');
						t.css({wordSpacing: (l.ratio * (l.ratio < 0 ? spaceShrink : spaceStretch)), display: 'inline-block'});
						$('#browser-assisted').append(t);
					});
				}
			}

			function browserTypeset() {
				var original = $('#browser'),
					width = original.width(),
					copy = original.clone(),
					text = copy.text(),
					lines = [],
					ratios = [],
					words = text.split(/\s/),
					position = 0,
					spaceWidth = 0,
					spaceStretch = 0,
					html = [];

				$('body').append(copy);

				// This piece of code calculates the positions of the line breaks added
				// by the browser by adding an invisible wrapper element to each word
				// and checking when its y-position changes.
				words.forEach(function (word, index) {
					var html = words.slice(0, index).append(['<span>' + word + '</span>'], words.slice(index + 1, words.length)),
						currentPosition = 0;

					copy.html(html.join(' '));

					currentPosition = copy.find('span').position().top;

					if (currentPosition != position) {
						lines.push([]);
						position = currentPosition;
					}

					lines.peek().push(word);
				});

				lines = lines.map(function (line) {
					return line.join(' ');
				});

				
				// We measure the width if the text is not justified and only a 
				// single line (i.e. the optimal line length.)
				copy.empty();
				copy.css({width: 'auto', display: 'inline', textAlign: 'left'});

				// This works under the assumption that a space is 1/3 of an em, and 
				// the stretch value is 1/6. Although the actual browser value may be
				// different, the assumption is valid as it is only used to compare
				// to the ratios calculated earlier.
				spaceWidth = copy.html('&nbsp;').width() / 2;

				lines.forEach(function (line, index) {
					// This conditional is to ensure we don't calculate the ratio
					// for the last line as it is not justified.
					if (index !== lines.length - 1) {
						copy.text(line);
						ratios.push((width - copy.width()) / ((line.split(/\s/).length - 1) * spaceWidth));
					} else {
						ratios.push(0);
					}
				});

				copy.remove();


				html.push('<ul>');
				ratios.forEach(function (ratio) {
					html.push('<li>');
					html.push(ratio.toFixed(3));
					html.push('</li>');
				});
				html.push('</ul>');

				$('#browser').parent().append(html.join(''));
			}

			jQuery(function ($) {
				$('#browser').text(text);
	
				canvasTypeset();
				browserTypeset();
			});
		</script>
	</body>
</html>


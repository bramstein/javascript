<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8" />
		<script type="text/javascript" src="core/object.js"></script>
		<script type="text/javascript" src="core/array.js"></script>
		<script type="text/javascript" src="core/function.js"></script>
		<script type="text/javascript" src="core/fun.js"></script>
		<script type="text/javascript" src="core/math.js"></script>
		<script type="text/javascript" src="chart/interval.js"></script>
		<script type="text/javascript" src="chart/coordinate.js"></script>
		<script type="text/javascript" src="chart/chart.js"></script>

		<script type="text/javascript">
		<![CDATA[
			var ctx = null;

			var xrange = new Interval(-10, 10);
			var yrange = new Interval(0, 20);
			var scalex, scaley;
			var pixelSizeX = 0;
			var pixelSizeY = 0;

			function f(x, y) {
				return Interval.sin(x.divide(32)).multiply(50).add(y).add(-100);
				
			//	return x.multiply(x).add(y).add(-100);
			}

			// to translate back we add -x.from to both coordinates

			// to scale we multiply with a scaling factor and (1 / scaling factor) to scale back
			// the scaling factor is the destiny vector divided by the original vector
			// to go from 1 to 100, you need a 100 / 1 = 100 scaling factor.


			function fillRect(x, y, w, h, data, r, g, b) {
				if (x.from >= 0 && x.to <= w && y.from >= 0 && y.to <= h) {
					var yf = Math.floor(y.from);
					var yt = Math.ceil(y.to);
					var xf = Math.floor(x.from);
					var xt = Math.ceil(x.to);

					for (var i = yf; i < yt; i += 1) {
						for (var j = xf; j < xt; j += 1) {
							var p = (i * w + j) * 4;
							data[p] = r;
							data[p + 1] = g;
							data[p + 2] = b;
							data[p + 3] = 255;
						}
					}
				}
			}

			function plotPixel(x, y, w, h, data, r, g, b) {
				var i = (y * w + x) * 4;
				data[i] = r;
				data[i+1] = g;
				data[i+2] = b;
				data[i+3] = 255;
			}

			function quadtree(data, x, y, w, h) {
				var F = f(x, y);

				if (F.from <= 0 && 0 <= F.to) {
					if (x.width() < 1 && y.width() < 1) {
						var cx = Math.ceil((x.from + x.to) / 2);
						var cy = Math.ceil((y.from + y.to) / 2);
						plotPixel(cx, cy, w, h, data, 255, 0, 0);
					}
					else {
						subdivide(data, x, y, w, h);
					}
				}
				else {
					//fillRect(x, y, w, h, data, 255, 255, 255);
				}
			}

		

			function subdivide(data, x, y, w, h) {
				var xk = (x.from + x.to) / 2;
				var yk = (y.from + y.to) / 2;

				quadtree(data, new Interval(x.from, xk), new Interval(y.from, yk), w, h);
				quadtree(data, new Interval(x.from, xk), new Interval(yk, y.to), w, h);
				quadtree(data, new Interval(xk, x.to), new Interval(yk, y.to), w, h);
				quadtree(data, new Interval(xk, x.to), new Interval(y.from, yk), w, h);
			}

			function draw() {

				var canvas = document.getElementById('canvas-context');

				if (canvas.getContext)
				{
					ctx = canvas.getContext('2d');

				//	ctx.fillStyle = "rgb(0, 0, 255)";
				//	ctx.fillRect(0,0, canvas.width, canvas.height);

					var image = ctx.getImageData(0, 0, canvas.width, canvas.height);

					var w = image.width, 
						h = image.height,
						data = image.data;


					quadtree(data, new Interval(0, w), new Interval(0, h), w, h);

					ctx.putImageData(image, 0, 0);
				}
			}


/*
			var ctx = null;

			var xrange = new Math.Interval(-10, 10);
			var yrange = new Math.Interval(0, 20);
			var scalex, scaley;
			var pixelSizeX = 0;
			var pixelSizeY = 0;

			function f(x) {
				//return Math.Interval.cos(x);
				return x.multiply(x);
			}

			function convert(a, b, p) {
				// to translate back we add -x.from to both coordinates

				// to scale we multiply with a scaling factor and (1 / scaling factor) to scale back
				// the scaling factor is the destiny vector divided by the original vector
				// to go from 1 to 100, you need a 100 / 1 = 100 scaling factor.

				return (p + Math.abs(a.from)) * (b.width() / a.width());
			}

			function fillRect(x, y, w, h, data, r, g, b) {
					var fx = (x.from + -xrange.from) * (w / xrange.width());
					var tx = (x.to + -xrange.from) * (w / xrange.width());

					var fy = (y.from + -yrange.from) * (h / yrange.width());
					var ty = (y.to + -yrange.from) * (h / yrange.width());

					fy = Math.floor(fy);
					ty = Math.ceil(ty);

					fx = Math.floor(fx);
					tx = Math.ceil(tx);


					if (fx >= 0 && tx <= w && fy >= 0 && ty <= h) {

					//	console.log(fx + "  " +  tx + " " + fy + " " + ty);
					
						for (var i = fy; i < ty; i += 1) {
							for (var j = fx; j < tx; j += 1) {
								var p = (i * w + j) * 4;
								data[p] = r;
								data[p + 1] = g;
								data[p + 2] = b;
								data[p + 3] = 255;
							}
						}
					}
			}

			function quadtree(data, x, y, w, h, depth) {
				var F = f(x);

				//console.log(F);

				//if (F.from <= 0 && 0 <= F.to) {
				if (y.hasSubset(F)) {
				//	console.log(F);

					if (x.width() < pixelSizeX && y.width() < pixelSizeY) {
						fillRect(x, y, w, h, data, 255,  0, 0);
					}
					else {
						subdivide(data, x, y, w, h, depth);
					}
				}
				else {
					//fillRect(x, y, w, h, data, 255, 255, 255);
				}
			}

		

			function subdivide(data, x, y, w, h, depth) {
				var xk = (x.from + x.to) / 2;
				var yk = (y.from + y.to) / 2;

				quadtree(data, new Math.Interval(x.from, xk), new Math.Interval(y.from, yk), w, h, depth);
				quadtree(data, new Math.Interval(x.from, xk), new Math.Interval(yk, y.to), w, h, depth);
				quadtree(data, new Math.Interval(xk, x.to), new Math.Interval(yk, y.to), w, h, depth);
				quadtree(data, new Math.Interval(xk, x.to), new Math.Interval(y.from, yk), w, h, depth);
			}

			function drawAxis(w, h, data) {
				fillRect(xrange, new Math.Interval(0, pixelSizeY), w, h, data, 0, 0, 0);
				fillRect(new Math.Interval(0, pixelSizeX), yrange, w, h, data, 0, 0, 0);
			}

			function draw() {

				var canvas = document.getElementById('canvas-context');

				if (canvas.getContext)
				{
					ctx = canvas.getContext('2d');

					ctx.fillStyle = "rgb(255, 255, 255)";
					ctx.fillRect(0,0, canvas.width, canvas.height);

					var image = ctx.getImageData(0, 0, canvas.width, canvas.height);

					var w = image.width, 
						h = image.height,
						data = image.data;

					

					scalex = w / xrange.width();
					scaley = h / yrange.width();

					pixelSizeX = 1 * (xrange.width() / w);
					pixelSizeY = 1 * (yrange.width() / h);

					//console.log(pixelSizeX + " " + pixelSizeY);
					//console.log(scalex + "  " + scaley);

					quadtree(data, xrange, yrange, w, h, 0);

					drawAxis(w, h, data);

					ctx.putImageData(image, 0, 0);
				}
			}
			*/
		]]>
		</script>
		<style>
			#canvas-context {
				border: 1px solid black;
			}
		</style>
	</head>
	<body onload="draw();">
		<canvas id="canvas-context" width="400" height="200"></canvas>
	</body>
</html>

/*global jQuery*/
(function ($) {
	var c = null,
		equation = null,
		m = /([\+\-]?\d*)[nN]([\+\-]?\d*)/;

	function parseEquation(str) {
		var tmp = [],
			result = {
				multiplier: 0,
				offset: 0
			};

		if (str === 'even') {
			str = '2n';
		} else if (str === 'odd') {
			str = '2n+1';
		} else if (/^\d*$/.test(str)) {
			str = '0n+' + str;
		}
		
		tmp = m.exec(str);

		if (tmp !== null) {
			result.multiplier = tmp[1] - 0;
			result.offset = tmp[2] - 0;
		}
		return result;
	}

	function generateCache(cells, equation) {
		// Retrieve parent tables, we need to check all of them because Sizzle works bottom up

		// TODO: perhaps we could optimize this a bit:
		// 1) We can retrieve the table and row by parentNode: row is cell.parentNode, table is cell.parentNode.parentNode.parentNode (the middle node is either tfoot, tbody, or thead---and in case of absence generated by the browser)
		// 2) cells are in document order, so perhaps we could use them directly in the code below and skip having to map from cell to table and back again
		var tables = $(cells).parents('table'),
			rows = $(cells).parents('tr'),
			rowCache = [],
			cache = [];

		// Initialize cache which we use for fast lookup of column indexes
		$.each(tables, function (i, t) {
			cache.push({
				simple: true,
				table: t,
				lookup: []
			});
		});

		// Check whether each table is simple by looping through all rows and comparing the cell counts. A table
		// is considered simple if all rows have an equal number of cells.
		$.each(rows, function (i, row) {
			var parent = $(row).parents('table').get(0);

			// We store the parent of each row in a cache so we don't need to look it up later.
			rowCache[i] = parent;

			$.each(cache, function (j, table) {
				var k = 0;
				if (table.table === parent) {
					if (cache[j].rowCount === undefined) {
						cache[j].rowCount = row.cells.length;		
					} else if (cache[j].rowCount !== row.cells.length) {
						cache[j].simple = false;
					}
				}
			});
		});

		$.each(cache, function (tableIndex, table) {
			var m = [];

			// If a table is not "simple" we build a lookup matrix which indicates in which column each cell is.
			// Credit for this algorithm goes to Matt Kruse of The Javascript Toolbox (http://www.javascripttoolbox.com/)
			if (!table.simple) {
				$.each(rows, function (rowIndex, row) {
					var parent = rowCache[rowIndex],
						first = 0;

					if (table.table === parent) {
						if (m[rowIndex] === undefined) {
							m[rowIndex] = [];
						}

						$.each(row.cells, function (cellIndex, cell) {
							var rowSpan = this.rowSpan || 1,
								colSpan = this.colSpan || 1,
								i = 0, j = 0;
							
							for (; i < m[rowIndex].length + 1; i += 1) {
								if (m[rowIndex][i] === undefined) {
									first = i;
									break;
								}
							}

							if (table.lookup[row.rowIndex] === undefined) {
								table.lookup[row.rowIndex] = [];
							}
							table.lookup[row.rowIndex][cell.cellIndex] = first;

							for (i = rowIndex; i < rowIndex + rowSpan; i += 1) {
								if (m[i] === undefined) {
									m[i] = [];
								}

								for (j = first; j < first + colSpan; j += 1) {
									m[i][j] = true;
								}
							}
						});
					}
				});
			}
		});
		return cache;
	}

	function nthCol(element) {
		var cellIndex = element.cellIndex,
			rowIndex = element.parentNode.rowIndex,
			parent = $(element).parents('table').get(0),
			colIndex = 0, result = false, i = 0, difference = 0;

		if (cellIndex === undefined || rowIndex === undefined || parent === undefined) {
			return result;
		}

		for (; i < c.length; i += 1) {
			if (c[i].table === parent) {
				if (c[i].simple) {
					difference = (element.cellIndex) - (equation.offset - 1);
				} else {
					difference = c[i].lookup[rowIndex][cellIndex] - (equation.offset - 1);					
				}

				if (equation.multiplier === 0) {
					return difference === 0;
				} else {
					return (difference % equation.multiplier === 0 && difference / equation.multiplier >= 0);
				}
			}
		}
		return result;
	}

	$.extend(jQuery.fn, {
		nthCol: function (e) {
			equation = parseEquation(e);
			c = generateCache(this);
			return $(this).filter(function () {
				return nthCol(this);
			});
		}
	});

	$.extend(jQuery.expr.match, {
		COLUMN: /:nth-col\((even|odd|[\dn\+\-]*)\)/
	});

	$.extend(jQuery.expr.preFilter, {
		COLUMN: function (match, items) {
			equation = parseEquation(match[1]);
			c = generateCache(items);
			return match;
		}
	});

	$.extend(jQuery.expr.filter, {
		COLUMN: nthCol
	});
})(jQuery);
